(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./client/src/main.js":[function(require,module,exports){
window.game = new Phaser.Game(600, 600, Phaser.CANVAS, '');
window.player = null;
window.socket = null;
window.level = null;

startGame();

function startGame() {
	// socket = io("https://limitless-brook-9339.herokuapp.com:443");
    socket = io("http://localhost:8000");

    require("./game/mods/phaser_enhancements");

	game.state.add("Boot", require("./game/states/boot"));
	game.state.add("Preloader", require("./game/states/preloader"));
	game.state.add("Lobby", require("./game/states/lobby"));
	game.state.add("StageSelect", require("./game/states/stage_select"));
	game.state.add("PendingGame", require("./game/states/pending_game"));
	game.state.add("Level", require("./game/states/level"));

	game.state.start('Boot');
};
},{"./game/mods/phaser_enhancements":"C:\\Projects\\bomb-arena\\client\\src\\game\\mods\\phaser_enhancements.js","./game/states/boot":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\boot.js","./game/states/level":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\level.js","./game/states/lobby":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\lobby.js","./game/states/pending_game":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\pending_game.js","./game/states/preloader":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\preloader.js","./game/states/stage_select":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\stage_select.js"}],"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\bomb.js":[function(require,module,exports){
var Bomb = function(x, y, id) {
	Phaser.Sprite.call(this, game, x, y, "bomb");
	this.id = id;

	this.anchor.setTo(.5, .5);
	game.physics.enable(this, Phaser.Physics.ARCADE);
  this.body.immovable = true;
	game.add.existing(this);
}

Bomb.prototype = Object.create(Phaser.Sprite.prototype);

Bomb.renderExplosion = function(explosions) {
	explosions.forEach(function(explosion) {
      var explosionSprite = new Phaser.Sprite(game, explosion.x, explosion.y, explosion.key, 0);
      explosionSprite.anchor.setTo(.5, .5);
      explosionSprite.animations.add("explode");
      explosionSprite.animations.getAnimation("explode").onComplete.add(function() {
       level.deadGroup.push(this);
      }, explosionSprite);

      if(explosion.hide) {
        game.world.addAt(explosionSprite, 1);
      } else {
        game.world.add(explosionSprite);
      }

      explosionSprite.play("explode", 17, false);
    });
}

module.exports = Bomb;
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\player.js":[function(require,module,exports){
var Bomb = require("./bomb");

var PLAYER_SPEED = 180;

var Player = function(x, y, id, color) {
	Phaser.Sprite.call(this, game, x, y, "bomberman_" + color);

  this.id = id;
  this.facing = "down";
  this.anchor.setTo(.5, .5);
  this.bombButtonJustPressed = false;

	game.physics.enable(this, Phaser.Physics.ARCADE);

  this.body.setSize(15, 16, 1, 15);

	this.animations.add("down", [0, 1, 2, 3, 4], 10, true);
  this.animations.add("up", [5, 6, 7, 8, 9], 10, true);
  this.animations.add("right", [10, 11, 12], 10, true);
  this.animations.add("left", [13, 14, 15], 10, true);

	game.add.existing(this);
};

Player.prototype = Object.create(Phaser.Sprite.prototype);

Player.prototype.handleInput = function() {
  this.handleMotionInput();
  this.handleBombInput();
};

Player.prototype.handleMotionInput = function() {
	  var moving = true;

    game.physics.arcade.collide(this, level.blockLayer);
    game.physics.arcade.collide(this, level.bombs);

  	if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT)) {
  		this.body.velocity.y = 0;
  		this.body.velocity.x = -PLAYER_SPEED;
  		this.facing = "left";
  	} else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT)) {
  		this.body.velocity.y = 0;
  		this.body.velocity.x = PLAYER_SPEED;
  		this.facing = "right";
  	} else if (game.input.keyboard.isDown(Phaser.Keyboard.UP)) {
  		this.body.velocity.x = 0;
  		this.body.velocity.y = -PLAYER_SPEED;
  		this.facing = "up";
  	} else if (game.input.keyboard.isDown(Phaser.Keyboard.DOWN)) {
  		this.body.velocity.x = 0;
  		this.body.velocity.y = PLAYER_SPEED;
  		this.facing = "down";
  	} else {
      moving = false;
  		this.body.velocity.x = 0;
  		this.body.velocity.y = 0;
  		this.animations.stop();
  	}

  	if(moving)  {
      this.animations.play(this.facing);
      socket.emit("move player", {x: this.position.x, y: this.position.y, facing: this.facing});
    }
  };

  Player.prototype.handleBombInput = function() {
    if(game.input.keyboard.isDown(Phaser.Keyboard.SPACEBAR) && !game.physics.arcade.overlap(this, level.bombs) && !this.bombButtonJustPressed) {
      this.bombButtonJustPressed = true;

      // Bombs for a player are identified by timestamp.
      socket.emit("place bomb", {x: this.body.position.x, y: this.body.position.y, id: game.time.now});
    } else if(!game.input.keyboard.isDown(Phaser.Keyboard.SPACEBAR) && this.bombButtonJustPressed) {
      this.bombButtonJustPressed = false;
    }
  };

module.exports = Player;
},{"./bomb":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\bomb.js"}],"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\remoteplayer.js":[function(require,module,exports){
var remotePlayerUpdateInterval = 100;

var RemotePlayer = function(x, y, id, color) {
	this.id = id;
	this.previousPosition = {x: x, y: y};
	this.lastMoveTime = 0;
	this.targetPosition;

	Phaser.Sprite.call(this, game, x, y, "bomberman_" + color);

	game.physics.enable(this, Phaser.Physics.ARCADE);

	this.anchor.setTo(.5, .5);

	this.animations.add('down', [0, 1, 2, 3, 4], 10, true);
  	this.animations.add('up', [5, 6, 7, 8, 9], 10, true);
  	this.animations.add('right', [10, 11, 12], 10, true);
  	this.animations.add('left', [13, 14, 15], 10, true);

	game.add.existing(this);
};

RemotePlayer.prototype = Object.create(Phaser.Sprite.prototype);

RemotePlayer.prototype.interpolate = function(lastFrameTime) {
	if(this.distanceToCover && lastFrameTime) {
		if((this.distanceCovered.x < Math.abs(this.distanceToCover.x) || this.distanceCovered.y < Math.abs(this.distanceToCover.y))) {
          var fractionOfTimeStep = (game.time.now - lastFrameTime) / remotePlayerUpdateInterval;
          var distanceCoveredThisFrameX = fractionOfTimeStep * this.distanceToCover.x;
          var distanceCoveredThisFrameY = fractionOfTimeStep * this.distanceToCover.y;

          this.distanceCovered.x += Math.abs(distanceCoveredThisFrameX);
          this.distanceCovered.y += Math.abs(distanceCoveredThisFrameY);

          this.position.x += distanceCoveredThisFrameX;
          this.position.y += distanceCoveredThisFrameY;
        } else {
          this.position.x = this.targetPosition.x;
          this.position.y = this.targetPosition.y;
        }
    }
}

module.exports = RemotePlayer;
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\round_end_animation.js":[function(require,module,exports){
var screenWidth = game.width;

var xOffset = 100 - screenWidth;
var yOffset = 60;

var headerXOffset = 150 - screenWidth;
var headerYOffset = 65;

var winnerPicXOffset = 225 - screenWidth;
var winnerPicYOffset = 310;

var defaultTextXOffset = 220 - screenWidth;
var defaultTextYOffset = 220;

var singleWinnerText = "Winner is...";
var roundEndTieText = "Draw! Winners are...";

// TODO: Refactor this method into a utility class, since it's already being used elsewhere (in lobby.js).
function configureText(text, color, size) {
	text.font = "Carter One";
	text.fill = color;
	text.fontSize = size;
};

function RoundEndAnimation(game, roundNumber, winningColors) {
	Phaser.Group.call(this, game);

	var roundEndWindow = game.add.image(xOffset, yOffset, "round_end_display");

	var header = game.add.text(headerXOffset, headerYOffset, "Round " + roundNumber + " Complete!")
	configureText(header, "white", 32);

	// Text and offset differ based on whether or not there was a tie.
	var actualTextXOffset = winningColors.length > 1 ? defaultTextXOffset - 55 : defaultTextXOffset;
	var actualTextToDisplay = winningColors.length > 1 ? roundEndTieText : singleWinnerText;

	var textObject = game.add.text(actualTextXOffset, defaultTextYOffset, actualTextToDisplay);
	configureText(textObject, "white", 28);
	textObject.alpha = 0;

	this.add(roundEndWindow);
	this.add(header);
	this.add(textObject);
	
	this.createAndAddWinnerImages(winningColors);
};

RoundEndAnimation.prototype = Object.create(Phaser.Group.prototype);

RoundEndAnimation.prototype.createAndAddWinnerImages = function(winningColors) {
	this.winnerImageIndices = [];
	var index = 3; // 3 is the index of the first winner image.

	winningColors.forEach(function(color) {
		var winnerPicImage = new Phaser.Image(game, winnerPicXOffset, winnerPicYOffset, "bomberman_head_" + color);

		winnerPicImage.scale = {x: 1.75, y: 1.75};
		winnerPicImage.alpha = 0;

		game.add.existing(winnerPicImage);
		this.add(winnerPicImage);
		this.winnerImageIndices.push(index++);
	}, this);
};

RoundEndAnimation.prototype.beginAnimation = function(callback) {
	var entranceTween = game.add.tween(this);
	entranceTween.to({x: screenWidth}, 300);
	entranceTween.onComplete.addOnce(function() {
		winnerTextTween.start();
	}, this);

	var winnerTextTween = game.add.tween(this.children[2]);
	winnerTextTween.to({alpha: 1}, 800);
	winnerTextTween.onComplete.addOnce(function() {
		winnerDisplayTween.start();
	}, this);

	var exitTween = game.add.tween(this);
	exitTween.to({x: 2 * screenWidth}, 300, Phaser.Easing.Default, false, 200);
	exitTween.onComplete.addOnce(callback);

	var winnerDisplayTween = this.generateWinnerImageTween(this.winnerImageIndices, exitTween);

	entranceTween.start();
};

RoundEndAnimation.prototype.generateWinnerImageTween = function(indices, nextTween) {
	var winnerImageTweens = [];
	var ctx = this;
	for (var i = 0; i < indices.length; i++) {
		(function(n) {
			var tween = game.add.tween(ctx.children[indices[n]]);
			tween.to({alpha: 1}, 900).to({alpha: 0}, 900);
			if(i < indices.length - 1) {
				tween.onComplete.addOnce(function() {
					winnerImageTweens[n + 1].start();
				});
			} else {
				tween.onComplete.addOnce(function() {
					nextTween.start();
				}, ctx);
			}
	
			winnerImageTweens.push(tween);
		})(i);
	}

	return winnerImageTweens[0];
};

module.exports = RoundEndAnimation;
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\mods\\phaser_enhancements.js":[function(require,module,exports){
/**
* Modified this method to be able to ignore certain children, so that select elements (such as scrolling background) can be preserved
* between states.
*/
Phaser.Group.prototype.removeAll = function (destroy, silent) {

    if (typeof destroy === 'undefined') { destroy = false; }
    if (typeof silent === 'undefined') { silent = false; }

    if (this.children.length === 0)
    {
        return;
    }

    var i = 0;

    do
    {
        if(this.children[i].doNotDestroy) {
            i++;
        }

        if (!silent && this.children[i].events)
        {
            this.children[i].events.onRemovedFromGroup.dispatch(this.children[i], this);
        }

        var removed = this.removeChild(this.children[i]);

        if (destroy && removed)
        {
            removed.destroy(true);
        }
    }
    while (this.children.length > i);

    this.cursor = null;

};
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\boot.js":[function(require,module,exports){
var Boot = function () {};

module.exports = Boot;

Boot.prototype = {

  preload: function () {
    // Fill in later.
  },

  create: function () {
    game.stage.disableVisibilityChange = true; // So that game doesn't stop when window loses focus.
    game.input.maxPointers = 1;

    if (game.device.desktop) {
      game.stage.scale.pageAlignHorizontally = true;
    } else {
      game.stage.scaleMode = Phaser.StageScaleMode.SHOW_ALL;
      game.stage.scale.minWidth =  480;
      game.stage.scale.minHeight = 260;
      game.stage.scale.maxWidth = 640;
      game.stage.scale.maxHeight = 480;
      game.stage.scale.forceLandscape = true;
      game.stage.scale.pageAlignHorizontally = true;
      game.stage.scale.setScreenSize(true);
    }

    game.state.start('Preloader');
  }
};

},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\level.js":[function(require,module,exports){
var BLACK_HEX_CODE = "#000000";

var Player = require('../entities/player');
var RemotePlayer = require('../entities/remoteplayer');
var Bomb = require('../entities/bomb');
var RoundEndAnimation = require('../entities/round_end_animation');

var remotePlayers = {};
var disableInputs = false;

var Level = function () {};

module.exports = Level;

Level.prototype = {
  init: function(tilemapName, players, id) {
    this.tilemapName = tilemapName;
    this.players = players;
    this.playerId = id;
  },

  create: function () {
    level = this;
    this.lastFrameTime;
    this.deadGroup = [];

    this.initializeMap();

    this.bombs = game.add.group();
    game.physics.enable(this.bombs, Phaser.Physics.ARCADE);
    game.physics.arcade.enable(this.blockLayer);

    this.setEventHandlers();
    this.initializePlayers();
  },

  createDimGraphic: function() {
    this.dimGraphic = game.add.graphics(0, 0);
    this.dimGraphic.alpha = .7;
    this.dimGraphic.beginFill(BLACK_HEX_CODE, 1); // (color, alpha)
    this.dimGraphic.drawRect(0, 0, game.camera.width, game.camera.height);
    this.dimGraphic.endFill(); // Draw to canvas
  },

  restartGame: function() {
    this.dimGraphic.destroy();
    disableInputs = false;

    if(player.alive) {
      player.destroy();
    }

    for(var i in remotePlayers) {
      var remotePlayer = remotePlayers[i];
      if(remotePlayer.alive) {
        remotePlayer.destroy();
      }
    }

    remotePlayers = {};
    player = null;
    this.deadGroup = [];
    this.lastFrameTime;
    this.initializePlayers();
  },

  onNewRound: function(data) {
    this.createDimGraphic();
    var datAnimationDoe = new RoundEndAnimation(game, data.completedRound, data.winningColors);
    disableInputs = true;
    datAnimationDoe.beginAnimation(this.beginRoundAnimation.bind(this, "round_" + (data.completedRound + 1), 
      this.restartGame.bind(this)));
  },

  // TODO: Figure out how this will know which animation to play.
  beginRoundAnimation: function(image, callback) {
    var beginRoundText = game.add.image(-600, game.camera.height / 2, image);
    beginRoundText.anchor.setTo(.5, .5);

    var tween = game.add.tween(beginRoundText);
    tween.to({x: game.camera.width / 2}, 300).to({x: 1000}, 300, Phaser.Easing.Default, false, 800).onComplete.add(callback);

    tween.start();
  },

  update: function() {
    if(player != null && player.alive == true && !disableInputs) {
          player.handleInput();
    }

  	this.stopAnimationForMotionlessPlayers();
  	this.storePreviousPositions();

    for(var id in remotePlayers) {
      remotePlayers[id].interpolate(this.lastFrameTime);
    }

    this.lastFrameTime = game.time.now;

    this.destroyDeadSprites();
  },

  destroyDeadSprites: function() {
    level.deadGroup.forEach(function(deadSprite) {
      deadSprite.destroy();
    });
  },

  render: function() {
    if(window.debugging == true) {
      game.debug.body(player);
    }
  },

  storePreviousPositions: function() {
    for(var id in remotePlayers) {
      remotePlayer = remotePlayers[id];
      remotePlayer.previousPosition = {x: remotePlayer.position.x, y: remotePlayer.position.y};
    }
  },

  stopAnimationForMotionlessPlayers: function() {
    for(var id in remotePlayers) {
      remotePlayer = remotePlayers[id];
      if(remotePlayer.previousPosition.x == remotePlayer.position.x && remotePlayer.previousPosition.y == remotePlayer.position.y) {
        remotePlayer.animations.stop();
      }
    }
  },

  setEventHandlers: function() {
    // Remember - these will actually be executed from the context of the Socket, not from the context of the level.
    socket.on("disconnect", this.onSocketDisconnect);
    socket.on("move player", this.onMovePlayer);
    socket.on("remove player", this.onRemovePlayer);
    socket.on("kill player", this.onKillPlayer);
    socket.on("place bomb", this.onPlaceBomb);
    socket.on("detonate", this.onDetonate);
    socket.on("new round", this.onNewRound.bind(this));
  },

  onSocketDisconnect: function() {
    console.log("Disconnected from socket server.");

    this.broadcast.emit("remove player", {id: this.id});
  },

  initializePlayers: function() {
    for(var i in this.players) {
      var data = this.players[i];
      if(data.id == this.playerId) {
        player = new Player(data.x, data.y, data.id, data.color);
      } else {
        remotePlayers[data.id] = new RemotePlayer(data.x, data.y, data.id, data.color);
      }
    }
  },

  initializeMap: function() {
    this.map = game.add.tilemap(this.tilemapName);
    this.map.addTilesetImage("tilez", "tiles", 40, 40);

    this.groundLayer = this.map.createLayer("Ground");
    this.groundLayer.resizeWorld();
    this.blockLayer = this.map.createLayer("Blocks");
    this.blockLayer.resizeWorld(); // What does this do?

    this.map.setCollision(127, true, "Blocks");

    // Send map data to server so it can do collisions.
    // TODO: do not allow the game to start until this operation is complete.
    var blockLayerData = game.cache.getTilemapData("levelOne").data.layers[1];

    socket.emit("register map", {tiles: blockLayerData.data, height: blockLayerData.height, width: blockLayerData.width});
  },

  onMovePlayer: function(data) {
    if(player && data.id == player.id) {
      return;
    }

    var movingPlayer = remotePlayers[data.id];

    if(movingPlayer.targetPosition) {
      if(data.x == movingPlayer.targetPosition.x && data.y == movingPlayer.targetPosition.y) {
        return;
      }
      movingPlayer.position.x = movingPlayer.targetPosition.x;
      movingPlayer.position.y = movingPlayer.targetPosition.y;

      movingPlayer.distanceToCover = {x: data.x - movingPlayer.targetPosition.x, y: data.y - movingPlayer.targetPosition.y};
      movingPlayer.distanceCovered = {x: 0, y:0};
    }

    movingPlayer.targetPosition = {x: data.x, y: data.y};
    movingPlayer.lastMoveTime = data.timestamp;

    movingPlayer.animations.play(data.facing);
  },

  onRemovePlayer: function(data) {
    var playerToRemove = remotePlayers[data.id];

    playerToRemove.destroy();

    delete remotePlayers[data.id];
  },

  onKillPlayer: function(data) {
    if(data.id == player.id) {
      console.log("You've been killed.");

      player.destroy();
    } else {
      var playerToRemove = remotePlayers[data.id];

      playerToRemove.destroy();

      delete remotePlayers[data.id];
    }
  },

  onPlaceBomb: function(data) {
   level.bombs.add(new Bomb(data.x, data.y, data.id));
  },

  onDetonate: function(data) {
    Bomb.renderExplosion(data.explosions);

    //remove bomb from group. bombs is a Phaser.Group to make collisions easier.
    level.bombs.forEach(function(bomb) {
      if(bomb && bomb.id == data.id) {
        bomb.destroy();
      }
    }, level);
  }
};

},{"../entities/bomb":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\bomb.js","../entities/player":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\player.js","../entities/remoteplayer":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\remoteplayer.js","../entities/round_end_animation":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\round_end_animation.js"}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\lobby.js":[function(require,module,exports){
var Lobby = function() {};

var initialSlotYOffset = 130;
var slotXOffset = 40;
var lobbySlotDistance = 60;

var textXOffset = 260;
var textYOffset = 25;
var repeatingBombTilesprite;

module.exports = Lobby;

Lobby.prototype = {
	init: function(rbts) {
		repeatingBombTilesprite = rbts;
	},

	create: function() {
		this.stateSettings = {
			empty: {
				outFrame: 0,
				overFrame: 1,
				text: "Host Game ", // For some reason, text gets slightly truncated if I don't append a space.
				callback: this.hostGameAction
			},
			joinable: {
				outFrame: 2,
				overFrame: 3,
				text: "Join Game ",
				callback: this.joinGameAction
			},
			settingup: {
				outFrame: 4,
				overFrame: 5,
				text: "Game is being set up... ",
				callback: null
			},
			inprogress: {
				outFrame: 4,
				overFrame: 5,
				text: "Game in Progress ",
				callback: null
			},
			full: {
				outFrame: 4,
				overFrame: 5,
				text: "Game Full ",
				callback: null
			}
		};

		if(repeatingBombTilesprite == null) {
			repeatingBombTilesprite = game.add.tileSprite(0, 0, 608, 608, "repeating_bombs");
		}

		repeatingBombTilesprite.doNotDestroy = true;

		this.backdrop = game.add.image(12.5, 12.5, "lobby_backdrop");

		this.slots = [];
		this.labels = [];

		var gameData = [{state: "empty"}, {state: "empty"}, {state: "joinable"}, {state: "insession"}];

		socket.emit("enter lobby");

		if(!socket.hasListeners("add slots")) {
			socket.on("add slots", this.addSlots.bind(this));
			socket.on("update slot", this.updateSlot.bind(this));
		}
	},

	update: function() {
		repeatingBombTilesprite.tilePosition.x++;
		repeatingBombTilesprite.tilePosition.y--;
	},

	addSlots: function(gameData) {
		if(this.slots.length > 0)  // TODO: get rid of this
			return;

		for(var i = 0; i < gameData.length; i++) {
			var callback = null;
			var state = gameData[i].state;
			var settings = this.stateSettings[state];
			var ctx = this;

			(function(n, fn) {
				if(fn != null) {
					callback = function() {
						fn(n);
					}
				}
			})(i, settings.callback);

			var slotYOffset = initialSlotYOffset + i * lobbySlotDistance;
			this.slots[i] = game.add.button(slotXOffset, slotYOffset, "game_slot", callback, null, settings.overFrame, settings.outFrame);
			
			var text = game.add.text(slotXOffset + textXOffset, slotYOffset + textYOffset, settings.text);
			this.configureText(text, "white", 18);
			text.anchor.setTo(.5, .5);

			this.labels[i] = text;
		}
	},

	configureText: function(text, color, size) {
		text.font = "Carter One";
		text.fill = color;
		text.fontSize = size;
	},

	hostGameAction: function(gameId) {
		socket.emit("host game", {gameId: gameId});
		socket.removeAllListeners();
		game.state.start("StageSelect", true, false, gameId, repeatingBombTilesprite);
	},

	joinGameAction: function(gameId) {
		socket.removeAllListeners();
		game.state.start("PendingGame", true, false, null, gameId, repeatingBombTilesprite);
	},

	updateSlot: function(updateInfo) {
		var settings = this.stateSettings[updateInfo.newState];
		var id = updateInfo.gameId;
		var button = this.slots[id];

		this.labels[id].setText(settings.text);
		button.setFrames(settings.overFrame, settings.outFrame);

		// Change callback of button
		button.onInputUp = new Phaser.Signal();

		button.onInputUp.add(function() { return settings.callback(id)}, this);
	}
};
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\pending_game.js":[function(require,module,exports){
var PendingGame = function() {}

module.exports = PendingGame;

var xOffset = 40;
var yOffset = 50;

var buttonXOffset = 330;
var startGameButtonYOffset = 400;
var leaveButtonYOffset = 450;

var characterSquareStartingX = 330;
var characterSquareStartingY = 80;
var characterSquareXDistance = 105;
var characterSquareYDistance = 100;

var characterOffsetX = 4.5;
var characterOffsetY = 4.5;

var numCharacterSquares = 6;

var repeatingBombTilesprite;

PendingGame.prototype = {
	init: function(tilemapName, gameId, rbts) {
		this.tilemapName = tilemapName;
		this.gameId = gameId;
		repeatingBombTilesprite = rbts;
	},

	create: function() {
		socket.emit("enter pending game", {gameId: this.gameId});

		var backdrop = game.add.image(xOffset, yOffset, "pending_game_backdrop");
		this.startGameButton = game.add.button(buttonXOffset, startGameButtonYOffset, "start_game_button", this.startGameAction, this,
			1, 0);
		this.leaveGameButton = game.add.button(buttonXOffset, leaveButtonYOffset, "leave_game_button", this.leaveGameAction, null, 1, 0);
		this.characterSquares = this.drawCharacterSquares(4);
		this.characterImages = [];
		this.numPlayersInGame = 0;

		socket.on("show current players", this.populateCharacterSquares.bind(this));
		socket.on("player joined", this.playerJoined.bind(this));
		socket.on("player left", this.playerLeft.bind(this));
		socket.on("start game on client", this.startGame);
	},

	update: function() {
		repeatingBombTilesprite.tilePosition.x++;
		repeatingBombTilesprite.tilePosition.y--;
	},

	drawCharacterSquares: function(numOpenings) {
		var characterSquares = [];
		var yOffset = characterSquareStartingY;
		var xOffset = characterSquareStartingX;

		for(var i = 0; i < numCharacterSquares; i++) {
			var frame = i < numOpenings ? 0 : 1;
			characterSquares[i] = game.add.sprite(xOffset, yOffset, "character_square", frame);
			if(i % 2 == 0) {
				xOffset += characterSquareXDistance;
			} else {
				xOffset = characterSquareStartingX;
				yOffset += characterSquareYDistance;
			}
		}

		return characterSquares;
	},

	populateCharacterSquares: function(data) {
		this.numPlayersInGame = 0;

		for(var playerId in data.players) {
			var color = data.players[playerId].color;
			this.characterImages[playerId] = game.add.image(this.characterSquares[this.numPlayersInGame].position.x + characterOffsetX, 
				this.characterSquares[this.numPlayersInGame].position.y + characterOffsetY, "bomberman_head_" + color);
			this.numPlayersInGame++;
		}
	},

	playerJoined: function(data) {
		this.numPlayersInGame++;
		var index = this.numPlayersInGame - 1;

		this.characterImages[data.id] = game.add.image(this.characterSquares[index].position.x + characterOffsetX, this.characterSquares[index].position.y + characterOffsetY, "bomberman_head_" +  data.color);
	},

	playerLeft: function(data) {
		for(var playerId in this.characterImages) {
			this.characterImages[playerId].destroy();
		}
		this.populateCharacterSquares(data);
	},

	// When the "start" button is clicked, send a message to the server to initialize the game.
	startGameAction: function() {
		socket.emit("start game on server");
	},

	leaveGameAction: function() {
		socket.emit("leave pending game");
		socket.removeAllListeners();
		game.state.start("Lobby", true, false, repeatingBombTilesprite);
	},

	startGame: function(data) {
		repeatingBombTilesprite.doNotDestroy = false;
		game.state.start("Level", true, false, data.mapName, data.players, this.id);
	}
}
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\preloader.js":[function(require,module,exports){
var Preloader = function () {};

module.exports = Preloader;

WebFontConfig = {
   google: { families: [ "Carter One" ] }
};

Preloader.prototype = {

  preload: function () {
    this.load.spritesheet("bomberman_white", "assets/sprites/bomberman.png", 28, 50);
    this.load.spritesheet("bomberman_black", "assets/sprites/bomberman_black.png", 28, 50);
    this.load.spritesheet("bomberman_blue", "assets/sprites/bomberman_blue.png", 28, 50);
    this.load.spritesheet("bomberman_red", "assets/sprites/bomberman_red.png", 28, 50);
    this.load.spritesheet("bomb", "assets/sprites/bomb.png", 26, 40);
    this.load.spritesheet("explosion_top", "assets/sprites/explosion_top.png", 30, 40);
    this.load.spritesheet("explosion_bottom", "assets/sprites/explosion_bottom.png", 30, 40);
    this.load.spritesheet("explosion_left", "assets/sprites/explosion_left.png", 40, 30);
    this.load.spritesheet("explosion_right", "assets/sprites/explosion_right.png", 40, 30);
    this.load.spritesheet("explosion_center", "assets/sprites/explosion_center.png", 30, 30);
    this.load.spritesheet("explosion_horizontal", "assets/sprites/explosion_horizontal.png", 40, 30);
    this.load.spritesheet("explosion_vertical", "assets/sprites/explosion_vertical.png", 30, 40);
    this.load.spritesheet("left_select_button", "assets/sprites/lobby/left_select_button.png", 60, 60);
    this.load.spritesheet("right_select_button", "assets/sprites/lobby/right_select_button.png", 60, 60);
    this.load.spritesheet("ok_button", "assets/sprites/lobby/ok_button.png", 60, 60);
    this.load.spritesheet("character_square", "assets/sprites/lobby/character_square.png", 89, 89);
    this.load.spritesheet("start_game_button", "assets/sprites/lobby/start_game_button.png", 202, 43);
    this.load.spritesheet("leave_game_button", "assets/sprites/lobby/leave_game_button.png", 202, 43);
    this.load.spritesheet("game_slot", "assets/sprites/lobby/game_slot.png", 522, 48);

    this.load.tilemap("levelOne", 'assets/levels/level_one.json', null, Phaser.Tilemap.TILED_JSON);
    this.load.image("tiles", "assets/tiles/tileset.png");
    this.load.image("select_stage", "assets/sprites/lobby/select_stage.png");
    this.load.image("limitless_brook_thumbnail", "assets/levels/thumbnails/limitless_brook_thumbnail.png");
    this.load.image("pending_game_backdrop", "assets/sprites/lobby/backdrop.png");
    this.load.image("round_end_display", "assets/sprites/lobby/end_of_round_window.png");
    this.load.image("repeating_bombs", "assets/sprites/lobby/repeating_bombs.png");
    this.load.image("lobby_backdrop", "assets/sprites/lobby/lobby_backdrop.png");
    this.load.image("bomberman_head_white", "assets/sprites/lobby/bomberman_head.png");
    this.load.image("bomberman_head_blue", "assets/sprites/lobby/bomberman_head_blue.png");
    this.load.image("bomberman_head_green", "assets/sprites/lobby/bomberman_head_green.png");
    this.load.image("bomberman_head_purple", "assets/sprites/lobby/bomberman_head_purple.png");
    this.load.image("bomberman_head_red", "assets/sprites/lobby/bomberman_head_red.png");
    this.load.image("bomberman_head_black", "assets/sprites/lobby/bomberman_head_black.png");
    this.load.image("round_1", "assets/sprites/lobby/round_1.png");
    this.load.image("round_2", "assets/sprites/lobby/round_2.png");
    this.load.image("final_round", "assets/sprites/lobby/final_round.png");
    this.load.image("tiebreaker", "assets/sprites/lobby/tiebreaker.png");

    game.load.script('webfont', '//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js');
  },

  create: function () {
    game.state.start("Lobby");
  }
};

},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\stage_select.js":[function(require,module,exports){
var StageSelect = function() {};

module.exports = StageSelect;

var xOffset = 40;
var yOffset = 50;

var thumbnailXOffset = 255;
var thumbnailYOffset = 150;

var stageNameYOffset = 328;

var repeatingBombTilesprite;

var stages = [
	{name: "Limitless Brook", thumbnailKey: "limitless_brook_thumbnail", tilemapName: "levelOne", maxPlayers: 4, size: "small"}
];

StageSelect.prototype = {
	init: function(gameId, rbts) {
		repeatingBombTilesprite = rbts;
		this.gameId = gameId;
	},

	create: function() {
		var selectionWindow = game.add.image(xOffset, yOffset, "select_stage");
		this.selectedStage = stages[0];

		this.leftButton = game.add.button(150, 180, "left_select_button", null, null, 1, 0);
		this.rightButton = game.add.button(400, 180, "right_select_button", null, null, 1, 0);
		this.okButton = game.add.button(495, 460, "ok_button", this.confirmStageSelection, this, 1, 0);

		this.loadStageInfo(stages[0]);
	},

	update: function() {
		repeatingBombTilesprite.tilePosition.x++;
		repeatingBombTilesprite.tilePosition.y--;
	},

	loadStageInfo: function(stage) {
		// Display Title
		this.thumbnail = game.add.image(thumbnailXOffset, thumbnailYOffset, stage.thumbnailKey);
		var text = game.add.text(game.camera.width / 2, stageNameYOffset, stage.name);
		this.configureText(text, "white", 28);
		text.anchor.setTo(.5, .5);

		// Display number of players
		var numPlayersText = game.add.text(145, 390, "Max # of players:   " + stage.maxPlayers);
		this.configureText(numPlayersText, "white", 18);

		// Display stage size
		var stageSizeText = game.add.text(145, 420, "Map size:   " + stage.size);
		this.configureText(stageSizeText, "white", 18);
	},

	configureText: function(text, color, size) {
		text.font = "Carter One";
		text.fill = color;
		text.fontSize = size;
	},

	confirmStageSelection: function() {
		socket.emit("select stage", {mapName: this.selectedStage.tilemapName});
		game.state.start("PendingGame", true, false, this.selectedStage.tilemapName, this.gameId, repeatingBombTilesprite);
	}
};
},{}]},{},["./client/src/main.js"]);
