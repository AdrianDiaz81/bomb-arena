(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./client/src/main.js":[function(require,module,exports){
window.game = new Phaser.Game(600, 600, Phaser.CANVAS, '');
window.player = null;
window.socket = null;
window.level = null;

startGame();

function startGame() {
	// socket = io("https://limitless-brook-9339.herokuapp.com:443");
    socket = io("http://localhost:8000");

	game.state.add('Boot', require('./game/states/Boot'));
	game.state.add('Preloader', require('./game/states/Preloader'));
	game.state.add('Level', require('./game/states/Level'));

	game.state.start('Boot');
};
},{"./game/states/Boot":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\Boot.js","./game/states/Level":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\Level.js","./game/states/Preloader":"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\Preloader.js"}],"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\Bomb.js":[function(require,module,exports){
var Bomb = function(x, y, id) {
	Phaser.Sprite.call(this, game, x, y, "bomb");
	this.id = id;

	this.anchor.setTo(.5, .5);
	game.physics.enable(this, Phaser.Physics.ARCADE);
	game.add.existing(this);
}

Bomb.prototype = Object.create(Phaser.Sprite.prototype);

module.exports = Bomb;
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\Player.js":[function(require,module,exports){
var Bomb = require('./bomb');

var PLAYER_SPEED = 180;

var Player = function(x, y) {
	Phaser.Sprite.call(this, game, x, y, 'bomberman');

  this.facing = 'down';
  this.anchor.setTo(.5, .5);

	game.physics.enable(this, Phaser.Physics.ARCADE);

	this.animations.add('down', [0, 1, 2, 3, 4], 10, true);
  	this.animations.add('up', [5, 6, 7, 8, 9], 10, true);
  	this.animations.add('right', [10, 11, 12], 10, true);
  	this.animations.add('left', [13, 14, 15], 10, true);

	game.add.existing(this);
};

Player.prototype = Object.create(Phaser.Sprite.prototype);

Player.prototype.handleInput = function() {
  this.handleMotionInput();
  this.handleBombInput();
};

Player.prototype.handleMotionInput = function() {
	  var moving = true;;

  	if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT)) {
  		this.body.velocity.y = 0;
  		this.body.velocity.x = -PLAYER_SPEED;
  		this.facing = 'left';
  	} else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT)) {
  		this.body.velocity.y = 0;
  		this.body.velocity.x = PLAYER_SPEED;
  		this.facing = 'right';
  	} else if (game.input.keyboard.isDown(Phaser.Keyboard.UP)) {
  		this.body.velocity.x = 0;
  		this.body.velocity.y = -PLAYER_SPEED;
  		this.facing = 'up';
  	} else if (game.input.keyboard.isDown(Phaser.Keyboard.DOWN)) {
  		this.body.velocity.x = 0;
  		this.body.velocity.y = PLAYER_SPEED;
  		this.facing = 'down';
  	} else {
      moving = false;
  		this.body.velocity.x = 0;
  		this.body.velocity.y = 0;
  		this.animations.stop();
  	}

  	if(moving)  {
      this.animations.play(this.facing);
      socket.emit("move player", {x: this.position.x, y: this.position.y, facing: this.facing});
    }
  };

  Player.prototype.handleBombInput = function() {
    if(game.input.keyboard.isDown(Phaser.Keyboard.SPACEBAR) && !game.physics.arcade.overlap(this, level.bombs)) {
      var bomb = new Bomb(this.position.x, this.position.y, game.time.now);

      // Bombs for a player are identified by timestamp.
      level.bombs.add(bomb);
      socket.emit("place bomb", {x: bomb.x, y: bomb.y, id: bomb.id});
    }
  };

module.exports = Player;
},{"./bomb":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\bomb.js"}],"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\RemotePlayer.js":[function(require,module,exports){
var remotePlayerUpdateInterval = 100;

var RemotePlayer = function(x, y, id) {
	this.id = id;
	this.previousPosition = {x: x, y: y};
	this.lastMoveTime = 0;
	this.targetPosition;

	Phaser.Sprite.call(this, game, x, y, "bomberman");

	game.physics.enable(this, Phaser.Physics.ARCADE);

	this.anchor.setTo(.5, .5);

	this.animations.add('down', [0, 1, 2, 3, 4], 10, true);
  	this.animations.add('up', [5, 6, 7, 8, 9], 10, true);
  	this.animations.add('right', [10, 11, 12], 10, true);
  	this.animations.add('left', [13, 14, 15], 10, true);

	game.add.existing(this);
};

RemotePlayer.prototype = Object.create(Phaser.Sprite.prototype);

RemotePlayer.prototype.interpolate = function(lastFrameTime) {
	if(this.distanceToCover && lastFrameTime) {
		if((this.distanceCovered.x < Math.abs(this.distanceToCover.x) || this.distanceCovered.y < Math.abs(this.distanceToCover.y))) {
          var fractionOfTimeStep = (game.time.now - lastFrameTime) / remotePlayerUpdateInterval;
          var distanceCoveredThisFrameX = fractionOfTimeStep * this.distanceToCover.x;
          var distanceCoveredThisFrameY = fractionOfTimeStep * this.distanceToCover.y;

          this.distanceCovered.x += Math.abs(distanceCoveredThisFrameX);
          this.distanceCovered.y += Math.abs(distanceCoveredThisFrameY);

          this.position.x += distanceCoveredThisFrameX;
          this.position.y += distanceCoveredThisFrameY;
        } else {
          this.position.x = this.targetPosition.x;
          this.position.y = this.targetPosition.y;
        }
    }
}

module.exports = RemotePlayer;
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\bomb.js":[function(require,module,exports){
arguments[4]["C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\Bomb.js"][0].apply(exports,arguments)
},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\Boot.js":[function(require,module,exports){
var Boot = function () {};

module.exports = Boot;

Boot.prototype = {

  preload: function () {
    // Fill in later.
  },

  create: function () {
    game.stage.disableVisibilityChange = true; // So that game doesn't stop when window loses focus.
    game.input.maxPointers = 1;

    if (game.device.desktop) {
      game.stage.scale.pageAlignHorizontally = true;
    } else {
      game.stage.scaleMode = Phaser.StageScaleMode.SHOW_ALL;
      game.stage.scale.minWidth =  480;
      game.stage.scale.minHeight = 260;
      game.stage.scale.maxWidth = 640;
      game.stage.scale.maxHeight = 480;
      game.stage.scale.forceLandscape = true;
      game.stage.scale.pageAlignHorizontally = true;
      game.stage.scale.setScreenSize(true);
    }

    game.state.start('Preloader');
  }
};

},{}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\Level.js":[function(require,module,exports){
var Player = require('../entities/Player');
var RemotePlayer = require('../entities/RemotePlayer');
var Bomb = require('../entities/Bomb');

var remotePlayers = {};

var Level = function () {};

module.exports = Level;

Level.prototype = {

  create: function () {
    level = this;
    this.lastFrameTime;

    this.map = game.add.tilemap("levelOne");
    this.map.addTilesetImage("tilez", "tiles", 40, 40);
    this.layer = this.map.createLayer('World');
    this.layer.resizeWorld();

    socket.emit("new player");

    this.bombs = game.add.group();
    game.physics.enable(this.bombs, Phaser.Physics.ARCADE);

    this.setEventHandlers();
  },

  update: function() {
    if(player != null) {
          player.handleInput();
    }

  	this.stopAnimationForMotionlessPlayers();
  	this.storePreviousPositions();

    for(var id in remotePlayers) {
      remotePlayers[id].interpolate(this.lastFrameTime);
    }

    this.lastFrameTime = game.time.now;
  },

  storePreviousPositions: function() {
    for(var id in remotePlayers) {
      remotePlayer = remotePlayers[id];
      remotePlayer.previousPosition = {x: remotePlayer.position.x, y: remotePlayer.position.y};
    }
  },

  stopAnimationForMotionlessPlayers: function() {
    for(var id in remotePlayers) {
      remotePlayer = remotePlayers[id];
      if(remotePlayer.previousPosition.x == remotePlayer.position.x && remotePlayer.previousPosition.y == remotePlayer.position.y) {
        remotePlayer.animations.stop();
      }
    }
  },

  setEventHandlers: function() {
    socket.on("assign id", this.onAssignId);
    socket.on("disconnect", this.onSocketDisconnect);
    socket.on("new player", this.onNewPlayer);
    socket.on("move player", this.onMovePlayer);
    socket.on("remove player", this.onRemovePlayer);
    socket.on("place bomb", this.onPlaceBomb);
    socket.on("detonate", this.onDetonate);
  },

  onAssignId: function(data) {
    console.log("creating new player at " + data.x + ", " + data.y);

    player = new Player(data.x, data.y);
    player.id = data.id;
  },

  onSocketDisconnect: function() {
    console.log("Disconnected from socket server.");

    this.broadcast.emit("remove player", {id: this.id});
  },

  onNewPlayer: function(data) {
    remotePlayers[data.id] = new RemotePlayer(data.x, data.y, data.id);
  },

  onMovePlayer: function(data) {
    if(!player || !player.id || data.id == player.id) {
      return;
    }

    var movingPlayer = remotePlayers[data.id];

    if(movingPlayer.targetPosition) {
      if(data.x == movingPlayer.targetPosition.x && data.y == movingPlayer.targetPosition.y) {
        return;
      }
      movingPlayer.position.x = movingPlayer.targetPosition.x;
      movingPlayer.position.y = movingPlayer.targetPosition.y;

      movingPlayer.distanceToCover = {x: data.x - movingPlayer.targetPosition.x, y: data.y - movingPlayer.targetPosition.y};
      movingPlayer.distanceCovered = {x: 0, y:0};
    }

    movingPlayer.targetPosition = {x: data.x, y: data.y};
    movingPlayer.lastMoveTime = data.timestamp;

    movingPlayer.animations.play(data.facing);
  },

  onRemovePlayer: function(data) {
    var playerToRemove = remotePlayers[data.id];

    playerToRemove.destroy();

    delete remotePlayers[data.id];
  },

  onPlaceBomb: function(data) {
   level.bombs.add(new Bomb(data.x, data.y, data.id));
  },

  onDetonate: function(data) {
    level.bombs.forEach(function(bomb) {
      if(bomb && bomb.id == data.id) {
        bomb.destroy();
      }
    });
  }
};
},{"../entities/Bomb":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\Bomb.js","../entities/Player":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\Player.js","../entities/RemotePlayer":"C:\\Projects\\bomb-arena\\client\\src\\game\\entities\\RemotePlayer.js"}],"C:\\Projects\\bomb-arena\\client\\src\\game\\states\\Preloader.js":[function(require,module,exports){
var Preloader = function () {};

module.exports = Preloader;

Preloader.prototype = {

  preload: function () {
    this.load.spritesheet("bomberman", "assets/sprites/bomberman.png", 28, 50);
    this.load.spritesheet("bomb", "assets/sprites/bomb.png", 26, 40);

    this.load.tilemap("levelOne", 'assets/levels/level_one.json', null, Phaser.Tilemap.TILED_JSON);
    this.load.image("tiles", "assets/tiles/tileset.png");
  },

  create: function () {
    game.state.start("Level");
  }
};

},{}]},{},["./client/src/main.js"]);
